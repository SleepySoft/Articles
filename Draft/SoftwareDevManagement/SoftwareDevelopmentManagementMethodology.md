# 前言

一直想写篇文章来记录和总结这些年软件开发管理的实践和心得，然而这一系列方法和理论头绪众多，就像一张网。
虽然你出指任意一点我能讲出很多，但让我介绍整张网我却不知道该从哪里入手。

但这件事也不能一直拖下去，所以我决定想到哪写到哪，文章的线索和架构留待以后重构吧。


# 前提

我不能妄言这一套开发实践能适合所有的公司和场景，毕竟同样是写程序，不同行业的差别巨大。
比如互联网更注重速度，对于质量和长期维护性不一定这么在乎。



# 理论

## Agile

敏捷开发这个概念炒了很多年，从我就职过的N家公司来看，就有N种不同的风格。我也曾经参加过各种培训和讨论，但其内容都非常抽象，甚至连方法论也不算。

直到后来我才想明白：敏捷开发的组织其实是想给人灌输一种理念，一种Mindset，它的主旨在于让软件开发人员自治。
为了对这一目标进行量化和指导，又引入了所谓的“成熟度（Maturity）”的概念。不同成熟度对应着不同的指导方法。
对于低成熟度的团队，指导应该更具体；而随着成熟度的提升，团队所需要的指导应该越来越少。

除了理念之外，它还提出了一系列活动。我们使用且认为有价值的活动如下：

+ 站会
> 这个概念居然是网上争论最多的地方。包括各种形式，各种整活，死保15分钟等等。实际上这只是一个同步当前情况的会议，
> 比起“今天做什么，接下来做什么”，“我遇到问题需要举手”反而更加重要。

+ Retrospective
> 大家都说这是Agile最重要的活动，我非常赞同。特别是在Maturity低的时候，在Retro会议上会发现很多问题。当然，最重要的是做开发管理的人有解决问题的心。

+ Sprint Release
> 这其实是敏捷的精髓，即每个Sprint都有“可演示”的交付物。这里的“可演示”是一个很微妙的词，它并不一定是指“可交付”或“可部署”。
> 它只要能演示，或者能通过测试代码（UT）验证功能完成即可。
>
> 从项目的角度来说，这个Sprint Release对软件来说是有很大的Benefit的，能为你挡住很多问题。
> 特别是和设备打交道的行业，PM总会问一个问题：我们用哪个版本过xx认证；或者说我们什么时候可以发一个做为阶段交付生产测试的版本。
> 这个时候如果软件已经有稳定Sprint Release的话，我们就可以回答：我们按Sprint做Release，我们可以用SPxx的Release作为这个交付版本。
>
> 这里的妙处就在于：用最新的发布或立即发布一个版本做这个事情通常是不稳妥的。只要软件实现的Scope满足要求，我们可以用几个Sprint前经过测试的版本作为交付。
> 
> **主动选择永远比被动发布好。**

+ Grooming
> 

+ SysEpic, Epic, Story, Task

## Design for Test

我在这里的意思并不是让你真的为“测试”去设计，而是在设计时问自己一句：这玩意该怎么测？

这里的测试并不是指测试人员的测试，而是开发人员“我证明它运行正确”的方法。


## 自动化测试

这里说的自动化测试并非指测试人员编写脚本，利用HIL等设备对设备进行测试，而是开发人员在交付之前的自动测试。
它的特点是仅依赖被测试的模块/程序，而不引入其依赖的模块。

仅验证功能。

其实事情非常单纯：一个设备/程序，它无外乎接受输入，并输出结果。无论系统多么复杂，无外如是。
唯一区别在于，输入的渠道可能很多，很复杂（如依赖于物理量，比如各种测量值、用户操作）；其输出的类型也很多，很复杂（物理输出，视觉反馈）。

我们要考虑的是，能不能将各种输入输出转变为可被程序检测的形式？最典型的就是通信。
比如说通过通信给让驱动接口层给出我们mock的数据而非真实测量值；同时将其输出在调用接口时直接转化成通信输出而非真正的IO操作。等等。

当然为了让程序无所察觉，没有侵入，这对程序的设计有所要求和考量。


## 需求


## 设计和文档


## Testcase


# 实践












