# 前言

我一直觉得Kotlin的协程设计得非常巧妙，在Android编程中我能体会到那种把异步做成了同步的感觉。于是找一个时间，探究一下它的设计和本质。

注意协程有多种模式，例如yield、promise/future等。只里仅讨论Kotlin的挂起函数模式。

这里先给出一段代码：


# 澄清几个概念


## 程序不存在


## 协程和线程

提到协程，总会提到它和线程的相似性，或者说它是轻量级的线程。我这里提出一个暴论：**协程和线程没有任何关系，它只是一个context。**

协程只是一段**可中断**的代码，并且这个中断还是需要代码中主动去做的（从协程的角度来说无法被抢占）。至于这段代码被谁驱动，那是调度器的事情，不在协程的概念中。

Kotlin和“可中断”和yield并无本质区别，只不过它提供了更丰富的场景支持。

> 上面这几段话有些抽象，没关系，只要有个印象就好。


## suspend函数

不用想太多，这仅是用来标记这是一个可中断的函数。有了这个标记，它就可以调用其它的可中断函数。

如上所说，这里的“可中断”并不意味着在协程的机制上可以在任意位置中断。相反，我们的可中断函数是通过调用其它的可中断函数来实现“中断”的。

当然协程不一定只能跑所谓的可中断函数，这其中的意义将在后续解释。


## 阻塞（耗时）的场景

文中阻塞操作等同于耗时操作。

这里再来一个暴论：程序阻塞的场景只有两种，同步操作和海量计算。

前者也包括了IO操作，因为在操作系统下IO的阻塞相当于同步操作。IO操作通常由相应的控制器主导，CPU不参与，它只等待结果，然后继续往下执行代码。
所谓的同步（进/线程间同步）操作也是在等待其它任务的完成，CPU才继续往下执行代码。本质上并无区别。

后者就是诸如挖矿的操作，CPU满负荷运行，不得休息。

这两个场景很重要，后面会提及。


# 为了解决什么问题

一般来说，主线程----特别是在有UI的情况下----是不能轻易阻塞的。道理很简单：主线程还要做其它事情，如果被一件事阻塞了，其它功能就没法跑了。

这种情况下如果我们需要执行阻塞操作，就需要启动一个线程，专门执行一个耗时的任务。这时会遇到一个非常难受的点：**我想得到它的结果，然后继续做一些事情。**

> 注意这里的“得到结果”包含“得到返回内容”和“知道它完成的时候”。

为了解决这个问题只有两种做法：Callback和Polling。


### Callback

这是最直接最及时的方法，但它最大的问题是 ---- 驱动Callback的正是这个线程。

这会带来多线程的传统问题（数据访问加锁），以及更新UI的问题（UI需要在主线程中更新）。

为了解决这些问题，传统的方法是将数据扔到主线程的队列中。要么将其转化为一个异步的任务，要么将其变成一个“信号”。但其本质都是下面所说的 ---- Polling


### Polling

很好理解，就是循环查询线程的运行结果。

promise/feature，async/await本质上就是这种模式（当然也可以join，这样就相当于又变回了阻塞操作）。

上面提到的“信号”，本质上也是Polling，只不过Polling的主体变成了框架的事件机制（也是个循环），看起来更“及时”一点。




















