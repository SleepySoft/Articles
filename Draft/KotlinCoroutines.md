# 前言

我一直觉得Kotlin的协程设计得非常巧妙，在Android编程中我能体会到那种把异步做成了同步的感觉。于是找一个时间，探究一下它的设计和本质。

注意协程有多种模式，例如yield、promise/future（严格来说属于异步而非协程）、async/await等。只里仅讨论Kotlin的挂起函数模式。

这里先给出一段代码，这段代码其实混合了三样东西，曾让我非常疑惑：

```
import kotlinx.coroutines.*

// 模拟阻塞操作
fun getUserName(): String {
    Thread.sleep(1000L) // 模拟耗时操作
    return "Alice"
}

// 模拟阻塞操作
fun getUserAvatar(): String {
    Thread.sleep(1000L) // 模拟耗时操作
    return "Avatar.png"
}

fun main() = runBlocking {
    GlobalScope.launch { // 创建一个新的协程
        val userName = withContext(Dispatchers.IO) { getUserName() } // 在 IO 调度器上运行阻塞操作
        val userAvatar = withContext(Dispatchers.IO) { getUserAvatar() } // 在 IO 调度器上运行阻塞操作
        println("User name: $userName, User avatar: $userAvatar") // 打印结果
    }
    println("Quit");
}
```

而在这篇文章结束后，希望大家都能顺利理解这段代码。


# 需要澄清的几个概念


## 顺序的程序必然顺序执行

这是一句废话。在同一个代码块中的程序代码必然是从上到下顺序执行（不谈编译器优化的情况），不可能出现跳过其中几行代码，随后再回头执行它们的情况。

之所以强调这一点，是希望你能在学习协程中保持清醒，不要被一些似是而非的鬼话绕进去。协程只是“看起来像”乱序执行，但它绝不可能违反本条断言。


## 协程和线程

提到协程，总会提到它和线程的相似性，或者说它是轻量级的线程。我这里提出一个暴论：**协程和线程没有任何关系，它只是一个context。**

协程只是一段**可中断**的代码，并且这个中断还是需要代码中主动去做的（从协程的角度来说无法被抢占）。至于这段代码被谁驱动，那是调度器的事情，不在协程的概念中。

> 上面这几段话有些抽象，没关系，只要有个印象就好。


## suspend函数

不用想太多，这仅是用来标记这是一个可挂起（可中断）的函数。有了这个标记，它就可以调用其它的挂起函数。

如上所说，这里的“挂起（可中断）”并不意味着这个函数可以在任意位置被挂起（中断）。相反，函数的“挂起（中断）”是通过主动调用其它挂起函数来实现的。

这也是suspend关键字的意义：调用挂起函数的函数自然也成了挂起函数，于是这种传传染机制保证了所有挂起函数都拥有同样的标记，没有漏网之鱼。

当然协程不一定只能跑所谓的可中断函数，这其中的意义将在后续解释。


## 阻塞（耗时）的场景

文中阻塞操作等同于耗时操作。

这里再来一个暴论：程序阻塞的场景只有两种，同步操作（如下面的解释，包括了IO（密集型）操作）和海量计算（CPU密集型操作）。

注：这里的“同步操作”和下面的“同步调用”的“同步”不是一个意思，指的是任务之间的同步。

前者也包括了IO操作，因为在操作系统下IO的阻塞相当于同步操作。IO操作通常由相应的控制器主导，CPU不参与，它只等待结果，然后继续往下执行代码。
所谓的同步（进/线程间同步）操作也是在等待其它任务的完成，CPU才继续往下执行代码。本质上并无区别。
甚至sleep()函数，我们也归为此类。因为CPU并没有sleep，只是过一段时间再过来跑代码罢了。这何尝不是时间上的同步。

后者就是诸如挖矿的操作，CPU满负荷运行，不得休息。

这两个场景很重要，后面会提及。


# 为了解决什么问题

一般来说，主线程----特别是在有UI的情况下----是不能轻易阻塞的。道理很简单：主线程还要做其它事情，如果被一件事阻塞了，其它功能就没法及时运行了。

这种情况下如果我们需要执行耗时的操作，就需要启动一个线程，专门执行一个耗时的任务。这时会遇到一个非常难受的点：**我想得到它的结果，然后继续做一些事情。**

> 注意这里的“得到结果”包含“得到返回内容”和“知道它完成的时候”。

为了解决这个问题只有两种做法：Callback和Polling。


### Callback

这是最直接最及时的方法，但它最大的问题是 ---- 驱动Callback的正是这个子线程。
这会带来多线程的传统问题（数据访问加锁），以及更新UI的问题（UI需要在主线程中更新）。

为了解决这些问题，传统的方法是将数据扔到主线程的队列中。要么将其转化为一个异步的任务，要么将其变成一个“信号”。但其本质都是下面所说的 ---- Polling


### Polling

很好理解，就是循环查询线程的运行结果。

promise/feature，async/await本质上就是这种模式（当然也可以join，这样就相当于又变回了阻塞操作）。

上面提到的“信号”，本质上也是Polling，只不过Polling的主体变成了框架的事件机制（也是个循环），看起来更“及时”一点。


### 

无论是Callback还是Polling，在代码形式上都会有一个问题：将本来相关的代码拆分到了多处：

> 有一个功能需要连续执行A,B,C,D,E这几个操作，其中B,D是耗时（阻塞的），而C和E和界面相关，需要在主线程中执行。
> 
> 传统方法是在执行完A后启动线程执行B，然后在B结束的通知事件（事件由主线程Handle）中执行C，再启动线程执行D，最后在D线束的通知事件中执行E。
> 
> 可以看到尽管A,B,C,D,E是同一个功能的几个步骤，但却被分散在程序中的好几个地方，中间还要加入诸如事件这样的同步机制，这样的代码看起来很痛苦。

> 如果觉得上面说的抽象，也可以想象更具体的场景：
> 
>> 程序需要先获取用户profile，再获取用户的头像，最后获取用户的首页推荐。
>
>> 存储数据需要先发一个擦除Flash的请求，在擦除操作结束后再进行写入，写入操作结束后再次读取，最后进行校验。

这时候有程序员想：我们能不能把A,B,C,D,E的代码都写在同一个函数里，但是却不影响主线程的执行，并且能保证C和E运行在界面的“环境”（线程）中呢。

于是，便有了Kotlin的协程设计。它不会使得并行操作更高效，但却能让程序写起来更方便。


# 设计

## 代码块和中断点

协程要运行的必然是一段代码，我们要考虑一个问题：如何让这段代码“让出”CPU？

对于线程来说，“让出”CPU有三种场景：

1. 线程调度，强制进行时间片切换，代码的执行可能中断在任何一个地方
2. 通过sleep函数主动让出CPU
3. 通过等待同步函数（mutex，signal）让出CPU，此处也包括一些同步调用的IO操作。如前所述，这类操作其本质也是调用同步函数。

而对于协程来说，它是不存在“抢占”的，它需要有一种方法主动让出CPU。这也是所谓挂起函数的意义。


## suspend的奥秘

对于计算机原理有研究的人来说，必然会有个疑问：为什么函数标记为suspend它就能让出CPU呢？它是什么原理？

这也是Kotlin的携程设计中非常独到的地方：Kotlin的协程关键字只有“suspend”。没有yield，并且async和await都是函数，而非关键字。

这就奇怪了，没有语言的支持，它是怎么实现协程的呢？

实际上，Kotlin使用了类似代码生成的方式实现了协程。如果函数中调用了挂起函数，那么生成的字节码会在这里分段，并写成switch/case的形式。
当一段代码执行完后，会将标志（continuation的label成员）赋值为下一段代码的case标签并返回。
这么一来，下次调用这个函数时，就能跳转到对应位置“继续”执行了。

不得不说，这种设计很有意思。理论上加入一个预处理器做代码生成，我们完全可以在C++中实现协程的功能。当然缺点就是最终生成的代码非常长。

至此，协程也不再神秘。它无外乎是编译器将代码打散放到queue里执行罢了，但从代码的形式上来说，却是一个连续的整体。


## 调度器和代码运行环境（线程）

我们知道协程的本质其实就是queue和代码块，那么问题来了：

1. 该用哪个线程去执行这些代码块？
2. 写过多线程的都知道：如果程序退出之前没将线程退出，可能会有以下两个问题：
+ 在使用某些框架的情况下，你的程序退出不了。
+ 没使用框架的情况下，程序结束线程被强杀，可能会导致不好的后果（文件损坏，事务中断）。

对于问题1，我们需要一个Dispatcher。不同的Dispatcher采用不同的调度策略，比如

> Dispatchers.Main 会在主线程中调度协程，可以用来执行UI操作。
> 
> Dispatchers.Default 会通过线程池调度协程
> 
> Dispatchers.IO 同样是线程池，但主要用来处理IO操作（和上面那个的区别后面会说）
> 
> Dispatchers.Unconfined 直接在调用的线程调度协程

对于问题2， 我们需要定义一个Scope，当Scope退出时，在Scope内的所有的协程都不应该再次被调度。

> 默认使用GlobalScope，程序退出Scope结束
> 
> 可以用父协程的job作为Scope，用来建立父子关系


## 其它

上文提到了这几个组件：
+ 挂起函数（Suspend Function）
+ 协程作用域（CoroutineScope）
+ 协程调度器（CoroutineDispatcher）

此外还有几个应该了解的重要的组件：
+ 协程构建器（Coroutine Builder）：如 launch、async/await和runBlocking
+ 协程异常处理（Exception Handling）：包含多种类型的配置参数，例如 Job 和 CoroutineName
+ 协程上下文（Coroutine Context）：包含了协程的Job和上面所说的调度器。

以及：
+ 通道（Channels）
+ 流（Flow）


# 推论

有了上面的概念，我们就可以解释最初的代码和针对使用场景能做出一些推论了：

## 最初的示例代码

正如前面所说，这段示例代码包含了三样东西：

#### runBlocking
> 这是一个干扰项。如前面所说，这个函数是一个协程启动器。和launch的区别是它会阻塞，直到内部的协程代码执行完毕。
> 的确，这样启动的协程和直接调用阻塞代码没有区别，一般像这样用在测试代码中，用以防止main直接退出导致协程中的代码得不到执行。

#### GlobalScope.launch
> 通常启动协程的方法，可以指定context参数，默认为Dispatchers.Default。这是最好理解的部分，也是最典型的使用方式。

#### withContext(Dispatchers.IO)
> 我认为这是协程框架最NB的部分，也是最难理解的部分。它可以在协程中直接切换一段代码运行的Context（可以粗暴理解为切换协程的调度器）。
> 也就是说，协程在Dispatchers.Default中启动，但我们可以将getUserName()和getUserAvatar()运行在Dispatchers.IO中。
> 
> 首先，这里使用了runBlocking并获取返回值，这是阻塞操作，从效果上来看跟直接调用这两个函数没有区别。
> 但amazing的地方是：这两个函数却是在另一个线程中运行的！在这里我只是“等”它们执行完毕而已，协程框架帮我们处理了同步操作。
> 
> 大家或许也发现了：这个特性同时也解决了多线程数据访问加锁的问题和更新UI的问题。
> 如果使用withContext(Dispatchers.Main)，那么它所包围的代码会运行在主线程中，对主线程中的数据进行访问毫无疑问是不需要加锁的，
> 更新UI更是没有问题。而从代码上看，除了把一部分代码放入括号（回调）里，形式上（代码顺序）和同步操作几乎一样。
> 

## CPU密集型操作和IO操作

如果说调用suspend函数是把代码拆分，由协程框架分块分次运行的话。
那么对于CPU密集型操作和调用非suspend函数的IO操作而言，协程的调度机制在其中是做不了任何事情的。
从本质上看，这类任务不得不放到子线程中执行。所以说协程框架为这两种场景分别设计了Dispatchers.Default和Dispatchers.IO。Main。

同是采用线程池调度它们的区别在于：

+ Dispatchers.Default：它的线程数限制为CPU核心数N（至少为2），因此只有N个任务可以在此调度器中并行运行，再多也没有意义。

+ Dispatchers.IO：默认有64个线程，原因在于I/O操作花费大量时间等待（I/O阻塞）但却不真正占用CPU资源，所以这个线程池不考虑CPU核心数的限制。

> 当然，相信不用我多说，这两类任务是绝不可能使用Dispatchers.Main的，不是吗？

## 获取协程的返回值

很多情况下，我们执行一个耗时操作，需要得到它的返回值。无论你把它比喻成玉米饼或是其它什么，都无法改变一个基本事实：绝不可能在调用返回前得到结果。

所以，该等还是得等，真正值得考虑的是如何让等待不影响主操作，并且在等到结果之后无痛地更新到我们想要的地方。

对于这两点，相信看完前文的你们都知道了：可以用合适的调度器去调用耗时操作，最后可以通过withContext来跨线程更新数据。

实际上除了开头的示例代码外，获取协程的返回值还有一种方式，而且是真正的“并行”：

```
fun main() = runBlocking {
    GlobalScope.launch { // 创建一个新的协程
        val userName = async { getUserName() } // 在 IO 调度器上运行阻塞操作
        val userAvatar = async { getUserAvatar() } // 在 IO 调度器上运行阻塞操作
        println("User name: ${userName.await()}, User avatar: ${userAvatar.await()}") // 打印结果
    }
    println("Quit");
}
```

区别在于：这里使用了async和await，区别在于这段代码是在await()的时候才进入等待的。在调用async()后，getUserName()和getUserAvatar()是可以并行执行的。

这个好理解，不多说。

## 其它

待续


# 参考及推荐文章

+ https://kotlinlang.org/docs/async-programming.html
+ https://chaoli.club/index.php/7531/0







