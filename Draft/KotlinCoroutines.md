# 前言

我一直觉得Kotlin的协程设计得非常巧妙，在Android编程中我能体会到那种把异步做成了同步的感觉。于是找一个时间，探究一下它的设计和本质。

注意协程有多种模式，例如yield、promise/future等。只里仅讨论Kotlin的挂起函数模式。

这里先给出一段代码：


# 需要澄清的几个概念


## 顺序的程序必然顺序执行

这是一句废话。在同一个代码块中的程序代码必然是从上到下顺序执行（不谈编译器优化的情况），不可能出现跳过其中几行代码，随后再回头执行它们的情况。

之所以强调这一点，是希望你能在学习协程中保持清醒，不要被一些似是而非的鬼话绕进去。协程只是“看起来像”乱序执行，但它绝不可能违反本条断言。


## 协程和线程

提到协程，总会提到它和线程的相似性，或者说它是轻量级的线程。我这里提出一个暴论：**协程和线程没有任何关系，它只是一个context。**

协程只是一段**可中断**的代码，并且这个中断还是需要代码中主动去做的（从协程的角度来说无法被抢占）。至于这段代码被谁驱动，那是调度器的事情，不在协程的概念中。

Kotlin和“可中断”和yield并无本质区别，只不过它提供了更丰富的场景支持。

> 上面这几段话有些抽象，没关系，只要有个印象就好。


## suspend函数

不用想太多，这仅是用来标记这是一个可挂起（可中断）的函数。有了这个标记，它就可以调用其它的挂起函数。

如上所说，这里的“挂起（可中断）”并不意味着在协程的机制上可以在任意位置挂起（中断）。相反，我们的挂起函数是通过调用其它的挂起函数来实现“挂起（中断）”的。

这也是suspend关键字的意义：调用挂起函数的函数自然也成了挂起函数，于是这种传传染机制保证了所有挂起函数都拥有同样的标记，没有漏网之鱼。

当然协程不一定只能跑所谓的可中断函数，这其中的意义将在后续解释。


## 阻塞（耗时）的场景

文中阻塞操作等同于耗时操作。

这里再来一个暴论：程序阻塞的场景只有两种，同步操作和海量计算。

前者也包括了IO操作，因为在操作系统下IO的阻塞相当于同步操作。IO操作通常由相应的控制器主导，CPU不参与，它只等待结果，然后继续往下执行代码。
所谓的同步（进/线程间同步）操作也是在等待其它任务的完成，CPU才继续往下执行代码。本质上并无区别。
甚至sleep()函数，我们也归为此类。因为CPU并没有sleep，只是过一段时间再过来跑代码罢了。这何尝不是时间上的同步。

后者就是诸如挖矿的操作，CPU满负荷运行，不得休息。

这两个场景很重要，后面会提及。


# 为了解决什么问题

一般来说，主线程----特别是在有UI的情况下----是不能轻易阻塞的。道理很简单：主线程还要做其它事情，如果被一件事阻塞了，其它功能就没法及时运行了。

这种情况下如果我们需要执行耗时的操作，就需要启动一个线程，专门执行一个耗时的任务。这时会遇到一个非常难受的点：**我想得到它的结果，然后继续做一些事情。**

> 注意这里的“得到结果”包含“得到返回内容”和“知道它完成的时候”。

为了解决这个问题只有两种做法：Callback和Polling。


### Callback

这是最直接最及时的方法，但它最大的问题是 ---- 驱动Callback的正是这个子线程。

这会带来多线程的传统问题（数据访问加锁），以及更新UI的问题（UI需要在主线程中更新）。

为了解决这些问题，传统的方法是将数据扔到主线程的队列中。要么将其转化为一个异步的任务，要么将其变成一个“信号”。但其本质都是下面所说的 ---- Polling


### Polling

很好理解，就是循环查询线程的运行结果。

promise/feature，async/await本质上就是这种模式（当然也可以join，这样就相当于又变回了阻塞操作）。

上面提到的“信号”，本质上也是Polling，只不过Polling的主体变成了框架的事件机制（也是个循环），看起来更“及时”一点。


### 

无论是Callback还是Polling，在代码形式上都会有一个问题：将本来相关的代码拆分到了多处：

> 有一个功能需要连续执行A,B,C,D,E这几个操作，其中B,D是耗时（阻塞的），而C和E和界面相关，需要在主线程中执行。
> 
> 传统方法是在执行完A后启动线程执行B，然后在B结束的通知事件（事件由主线程Handle）中执行C，再启动线程执行D，最后在D线束的通知事件中执行E。
> 
> 可以看到尽管A,B,C,D,E是同一个功能的几个步骤，但却被分散在程序中的好几个地方，中间还要加入诸如事件这样的同步机制，这样的代码看起来很痛苦。

> 如果觉得上面说的抽象，也可以想象更具体的场景：
> 
>> 程序需要先获取用户profile，再获取用户的头像，最后获取用户的首页推荐。
>
>> 存储数据需要先发一个擦除Flash的请求，在擦除操作结束后再进行写入，写入操作结束后再次读取，最后进行校验。

这时候有程序员想：我们能不能把A,B,C,D,E的代码都写在同一个函数里，但是却不影响主线程的执行，并且能保证C和E运行在界面的“环境”（线程）中呢。

于是，便有了Kotlin的协程设计。它不会使得并行操作更高效，但却能让程序写起来更方便。


# 设计

## 代码块和中断点

协程要运行的必然是一段代码，我们要考虑一个问题：如何让这段代码“让出”CPU？

对于线程来说，“让出”CPU有三种场景：

1. 线程调度，强制进行时间片切换，代码的执行可能中断在任何一个地方
2. 通过sleep函数主动让出CPU
3. 通过等待同步函数（mutex，signal）让出CPU，此处也包括一些同步调用的IO操作。如前所述，这类操作其本质也是调用同步函数。

而对于协程来说，它是不存在“抢占”的，它需要有一种方法主动让出CPU。这也是所谓挂起函数的意义。


## suspend的奥秘

对于计算机原理有研究的人来说，必然会有个疑问：为什么函数标记为suspend它就能让出CPU呢？它是什么原理？

这也是Kotlin的携程设计中非常独到的地方：Kotlin的协程关键字只有“suspend”。没有yield，并且async和await都是函数，而非关键字。

这就奇怪了，没有语言的支持，它是怎么实现协程的呢？

实际上，Kotlin使用了类似代码生成的方式实现了协程。如果函数中调用了挂起函数，那么生成的字节码会在这里分段，并写成switch/case的形式。
当一段代码执行完后，会将标志（continuation的label成员）赋值为下一段代码的case标签并返回。
这么一来，下次调用这个函数时，就能跳转到对应位置“继续”执行了。

不得不说，这种设计很有意思。理论上加入一个预处理器做代码生成，我们完全可以在C++中实现协程的功能。当然缺点就是最终生成的代码非常长。

至此，协程也不再神秘。它无外乎是编译器将代码打散放到queue里执行罢了，但从代码的形式上来说，却是一个连续的整体。


## 调度器和代码运行环境（线程）

我们知道协程的本质其实就是queue和代码块，那么问题来了：

1. 该用哪个线程去执行这些代码块？
2. 写过多线程的都知道：如果程序退出之前没将线程退出，可能会有以下两个问题：
+ 在使用某些框架的情况下，你的程序退出不了。
+ 没使用框架的情况下，程序结束线程被强杀，可能会导致不好的后果（文件损坏，事务中断）。

对于问题1，我们需要一个Dispatcher。不同的Dispatcher采用不同的调度策略，比如

> Dispatchers.Main 会在主线程中调度协程，可以用来执行UI操作。
> 
> Dispatchers.Default 会通过线程池调度协程
> 
> Dispatchers.IO 同样是线程池，但主要用来处理IO操作（和上面那个的区别后面会说）
> 
> Dispatchers.Unconfined 直接在调用的线程调度协程

对于问题2， 我们需要定义一个Scope，当Scope退出时，在Scope内的所有的协程都不应该再次被调度。

> 默认使用GlobalScope，程序退出Scope结束
> 
> 可以用父协程的job作为Scope，用来建立父子关系


## 启动和同步



## Context



# 参考及推荐文章

https://kotlinlang.org/docs/async-programming.html

https://chaoli.club/index.php/7531/0

或者正文：
    https://sdl.moe/post/kt-coroutines-01/
    https://sdl.moe/post/kt-coroutines-02/







